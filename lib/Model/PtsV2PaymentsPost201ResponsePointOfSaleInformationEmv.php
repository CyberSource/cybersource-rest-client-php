<?php
/**
 * PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv
 *
 * PHP version 5
 *
 * @category Class
 * @package  CyberSource
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * CyberSource Merged Spec
 *
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CyberSource\Model;

use \ArrayAccess;

/**
 * PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv Class Doc Comment
 *
 * @category    Class
 * @package     CyberSource
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'ptsV2PaymentsPost201Response_pointOfSaleInformation_emv';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'tags' => 'string',
        'chipValidationType' => 'string',
        'chipValidationResult' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerFormats = [
        'tags' => null,
        'chipValidationType' => null,
        'chipValidationResult' => null
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'tags' => 'tags',
        'chipValidationType' => 'chipValidationType',
        'chipValidationResult' => 'chipValidationResult'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'tags' => 'setTags',
        'chipValidationType' => 'setChipValidationType',
        'chipValidationResult' => 'setChipValidationResult'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'tags' => 'getTags',
        'chipValidationType' => 'getChipValidationType',
        'chipValidationResult' => 'getChipValidationResult'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['tags'] = isset($data['tags']) ? $data['tags'] : null;
        $this->container['chipValidationType'] = isset($data['chipValidationType']) ? $data['chipValidationType'] : null;
        $this->container['chipValidationResult'] = isset($data['chipValidationResult']) ? $data['chipValidationResult'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        if (!is_null($this->container['tags']) && (strlen($this->container['tags']) > 1998)) {
            $invalid_properties[] = "invalid value for 'tags', the character length must be smaller than or equal to 1998.";
        }

        if (!is_null($this->container['chipValidationType']) && (strlen($this->container['chipValidationType']) > 2)) {
            $invalid_properties[] = "invalid value for 'chipValidationType', the character length must be smaller than or equal to 2.";
        }

        if (!is_null($this->container['chipValidationResult']) && (strlen($this->container['chipValidationResult']) > 1)) {
            $invalid_properties[] = "invalid value for 'chipValidationResult', the character length must be smaller than or equal to 1.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if (strlen($this->container['tags']) > 1998) {
            return false;
        }
        if (strlen($this->container['chipValidationType']) > 2) {
            return false;
        }
        if (strlen($this->container['chipValidationResult']) > 1) {
            return false;
        }
        return true;
    }


    /**
     * Gets tags
     * @return string
     */
    public function getTags()
    {
        return $this->container['tags'];
    }

    /**
     * Sets tags
     * @param string $tags EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.  For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing. PIN debit processing is available only on FDC Nashville Global.  **Important** The following tags contain sensitive information and **must not** be included in this field:   - `56`: Track 1 equivalent data  - `57`: Track 2 equivalent data  - `5A`: Application PAN  - `5F20`: Cardholder name  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)  - `99`: Transaction PIN  - `9F0B`: Cardholder name (extended)  - `9F1F`: Track 1 discretionary data  - `9F20`: Track 2 discretionary data  For captures, this field is required for contact EMV transactions. Otherwise, it is optional.  For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits. Otherwise, it is optional.  **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits, you must include the following tags in this field. For all other types of EMV transactions, the following tags are optional.   - `95`: Terminal verification results  - `9F10`: Issuer application data  - `9F26`: Application cryptogram   #### CyberSource through VisaNet - In Japan: 199 bytes - In other countries: String (252)  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### JCN Gateway The following tags must be included: - `4F`: Application identifier - `84`: Dedicated file name  Data length: 199 bytes  #### All other processors: String (999)  #### Used by Authorization: Optional Authorization Reversal: Optional Credit: Optional PIN Debit processing (purchase, credit and reversal): Optional
     * @return $this
     */
    public function setTags($tags)
    {
        if (!is_null($tags) && (strlen($tags) > 1998)) {
            throw new \InvalidArgumentException('invalid length for $tags when calling PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv., must be smaller than or equal to 1998.');
        }

        $this->container['tags'] = $tags;

        return $this;
    }

    /**
     * Gets chipValidationType
     * @return string
     */
    public function getChipValidationType()
    {
        return $this->container['chipValidationType'];
    }

    /**
     * Sets chipValidationType
     * @param string $chipValidationType Entity or service that provided the validation results returned in `chipValidationResult`.  Possible values:  - `02`: MasterCard on-behalf pre-validation service (The MasterCard authorization platform validated the M/Chip cryptogram before the authorization request reached the issuer.)  - `03`: MasterCard on-behalf stand-in service (The MasterCard authorization platform validated the M/Chip cryptogram because the issuer was not available.)  - `50`: Issuer  - `90`: Chip fall-back transaction downgrade process (The chip could not be read.)  This field is returned only for NFC payment network tokenization transactions with MasterCard.  **Note** No CyberSource through VisaNet acquirers support EMV at this time.
     * @return $this
     */
    public function setChipValidationType($chipValidationType)
    {
        if (!is_null($chipValidationType) && (strlen($chipValidationType) > 2)) {
            throw new \InvalidArgumentException('invalid length for $chipValidationType when calling PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv., must be smaller than or equal to 2.');
        }

        $this->container['chipValidationType'] = $chipValidationType;

        return $this;
    }

    /**
     * Gets chipValidationResult
     * @return string
     */
    public function getChipValidationResult()
    {
        return $this->container['chipValidationResult'];
    }

    /**
     * Sets chipValidationResult
     * @param string $chipValidationResult Cryptogram validation results returned by the entity or service specified in `chipValidationType`.  Possible values: - `A`: Application cryptogram is valid, but the application transaction counter (ATC) is outside allowed range. (A large jump in ATC values may indicate data copying or other fraud.) - `C`: Chip validation was completed successfully. - `E`: Application cryptogram is valid but the ATC indicates possible replay fraud. - `F`: Format error in the chip data. - `G`: Application cryptogram is valid but is not a valid authorization request cryptogram (ARQC). - `I`: Application cryptogram is invalid. - `T`: Application cryptogram is valid but terminal verification results (TVR) or card verification results (CVR) are invalid. - `U`: Application cryptogram could not be validated because of a technical error.  This field is returned only for NFC payment network tokenization transactions with MasterCard.  **Note** No CyberSource through VisaNet acquirers support EMV at this time.
     * @return $this
     */
    public function setChipValidationResult($chipValidationResult)
    {
        if (!is_null($chipValidationResult) && (strlen($chipValidationResult) > 1)) {
            throw new \InvalidArgumentException('invalid length for $chipValidationResult when calling PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv., must be smaller than or equal to 1.');
        }

        $this->container['chipValidationResult'] = $chipValidationResult;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\CyberSource\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\CyberSource\ObjectSerializer::sanitizeForSerialization($this));
    }
}


